"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcTagsForModule = void 0;
const getFs_1 = __importDefault(require("../fs/getFs"));
const user_error_1 = require("../error/user-error");
const calcTagsForModule = (moduleDir, rootDir, tagConfig, autoTagging = true) => {
    if (moduleDir === rootDir) {
        return ['root'];
    }
    const fs = (0, getFs_1.default)();
    const paths = fs.split(moduleDir.slice(rootDir.length + 1));
    const placeholders = {};
    const tags = traverseTagConfig(paths, tagConfig, placeholders, moduleDir, [], true);
    if (tags === false) {
        if (!autoTagging) {
            throw new user_error_1.NoAssignedTagError(moduleDir);
        }
        return ['noTag'];
    }
    return tags;
};
exports.calcTagsForModule = calcTagsForModule;
function traverseTagConfig(paths, tagConfig, placeholders, moduleDir, tagConfigPath, isRoot) {
    for (const pathMatcher in tagConfig) {
        if (isRoot) {
            placeholders = {};
        }
        // might be reset below
        const originalPlaceholders = Object.assign({}, placeholders);
        const { matcherContext, matches, pathFragmentSpan } = matchSegment(pathMatcher, paths, placeholders);
        if (!matches) {
            continue;
        }
        const restPaths = paths.slice(pathFragmentSpan);
        const value = tagConfig[pathMatcher];
        if (restPaths.length === 0) {
            assertLeafHasTag(value, [...tagConfigPath, pathMatcher]);
            const tagProperty = value;
            if (typeof tagProperty === 'function') {
                return addToTags(tagProperty(placeholders, matcherContext), placeholders, moduleDir);
            }
            else {
                return addToTags(tagProperty, placeholders, moduleDir);
            }
        }
        else {
            if (isTagConfigValue(value)) {
                /**
                 * Nested Module use case. Example:
                 *
                 * tags requested for moduleDir libs/src/holiday/data
                 *
                 * TagConfig:
                 * {
                 *   'libs/<domain>/src': 'nx-lib', // <-- we are here!
                 *   'libs/<domain>/src/data': ['domain:<domain>']
                 * }
                 */
                placeholders = originalPlaceholders;
                continue;
            }
            return traverseTagConfig(restPaths, value, placeholders, moduleDir, [...tagConfigPath, pathMatcher], false);
        }
    }
    return false;
}
function isTagConfigValue(value) {
    return !(typeof value === 'object' && !Array.isArray(value));
}
function assertLeafHasTag(value, tagConfigPath) {
    if (!isTagConfigValue(value)) {
        throw new user_error_1.TagWithoutValueError(tagConfigPath.join('/'));
    }
}
function addToTags(newTags, placeholders, moduleDir) {
    return (Array.isArray(newTags) ? newTags : [newTags]).map((tag) => replacePlaceholdersInTag(tag, placeholders, moduleDir));
}
function replacePlaceholdersInTag(tag, placeholders, fullDir) {
    let replacedTag = tag;
    for (const placeholder in placeholders) {
        const value = placeholders[placeholder];
        replacedTag = replacedTag.replace(new RegExp(`<${placeholder}>`, 'g'), value);
    }
    const unavailablePlaceholder = replacedTag.match(/<([a-zA-Z]+)>/);
    if (unavailablePlaceholder) {
        throw new user_error_1.InvalidPlaceholderError(unavailablePlaceholder[1], fullDir);
    }
    return replacedTag;
}
function isRegularExpression(segment) {
    return segment.startsWith('/') && segment.endsWith('/');
}
function handlePlaceholderMatching(pathMatcher, currentPath, placeholderMatch, placeholders) {
    const placeholderRegex = pathMatcher.replace(/<[a-zA-Z]+>/g, '(.+)');
    const pathMatch = currentPath.match(new RegExp(placeholderRegex));
    if (!pathMatch) {
        return false;
    }
    placeholderMatch.forEach((placeholder, ix) => {
        if (placeholder in placeholders) {
            throw new user_error_1.ExistingTagPlaceholderError(placeholder);
        }
        placeholders[placeholder] = pathMatch[ix + 1];
    });
    return true;
}
function handleRegularExpression(paths, segment) {
    const currentPath = paths[0];
    const regExpString = segment.substring(1, segment.length - 1);
    const regExp = new RegExp(regExpString);
    const match = currentPath.match(regExp);
    return match && match[0] === currentPath ? match : null;
}
function matchSegment(segmentMatcher, paths, placeholders) {
    var _a;
    let matches = true;
    let pathFragment = paths[0];
    const matcherContext = { segment: pathFragment };
    let pathFragmentSpan = 1;
    if (isRegularExpression(segmentMatcher)) {
        const regExpMatchArray = handleRegularExpression(paths, segmentMatcher);
        if (regExpMatchArray) {
            matcherContext.regexMatch = regExpMatchArray;
        }
        else {
            matches = false;
        }
    }
    else {
        pathFragmentSpan = segmentMatcher.split('/').length;
        if (pathFragmentSpan > paths.length) {
            matches = false;
        }
        pathFragment = paths.slice(0, pathFragmentSpan).join('/');
        const placeholderMatch = ((_a = segmentMatcher.match(/<[a-zA-Z]+>/g)) !== null && _a !== void 0 ? _a : []).map((str) => str.slice(1, str.length - 1));
        if (placeholderMatch.length) {
            matches = handlePlaceholderMatching(segmentMatcher, pathFragment, placeholderMatch, placeholders);
        }
        else {
            if (segmentMatcher !== pathFragment) {
                matches = false;
            }
        }
    }
    return {
        pathFragment,
        pathFragmentSpan,
        matches,
        matcherContext,
    };
}
//# sourceMappingURL=calc-tags-for-module.js.map