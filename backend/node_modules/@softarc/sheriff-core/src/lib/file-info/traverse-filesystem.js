"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePotentialTsPath = resolvePotentialTsPath;
const unassigned_file_info_1 = __importDefault(require("./unassigned-file-info"));
const getFs_1 = __importDefault(require("../fs/getFs"));
const ts = __importStar(require("typescript"));
const fs_path_1 = require("./fs-path");
// https://stackoverflow.com/questions/71815527/typescript-compiler-apihow-to-get-absolute-path-to-source-file-of-import-module
/**
 * This function generates the FileInfo tree.
 * It starts with the entry TypeScript file (in Angular main.ts) and follows
 * all the imports.
 *
 * It does not follow an import when it is an external library, i.e. comes from
 * node_modules or is already part of the tree.
 *
 * To improve the testability, we use abstraction whenever access to the
 * filesystem happens. In case the abstraction does not emulate the original's
 * behaviour, "strange bugs" might occur. Look out for them.
 *
 * fixPathSeparators is necessary to replace the static '/' path separator
 * with the one from the OS.
 *
 * @param fsPath Filename to traverse from
 * @param fileInfoDict Dictionary of traversed files to catch circularity
 * @param tsData
 * @param runOnce traverse only once. needed for ESLint mode
 * @param fileContent if passed, is used instead the content of @fsPath.
 * necessary for unsaved files inESLint
 */
const traverseFilesystem = (fsPath, fileInfoDict, tsData, runOnce = false, fileContent) => {
    const { paths, configObject, sys, rootDir } = tsData;
    const fileInfo = new unassigned_file_info_1.default(fsPath, []);
    fileInfoDict.set(fsPath, fileInfo);
    const fs = (0, getFs_1.default)();
    fileContent = fileContent !== null && fileContent !== void 0 ? fileContent : fs.readFile(fsPath);
    const preProcessedFile = ts.preProcessFile(fileContent);
    const resolveFn = (moduleName) => ts.resolveModuleName(moduleName, fsPath, configObject.options, sys);
    for (const importedFile of preProcessedFile.importedFiles) {
        const { fileName } = importedFile;
        const resolvedImport = resolveFn(fileName);
        let importPath;
        if (resolvedImport.resolvedModule) {
            const { resolvedFileName } = resolvedImport.resolvedModule;
            if (!resolvedImport.resolvedModule.isExternalLibraryImport) {
                importPath = fixPathSeparators(resolvedFileName);
                if (!importPath.startsWith(rootDir)) {
                    throw new Error(`${importPath} is outside of root ${rootDir}`);
                }
            }
        }
        // just skip it
        else if (fileName.endsWith('.json')) {
        }
        // might be an undetected dependency in node_modules
        // or an incomplete import (= developer is still typing),
        // if we read from an unsaved file via ESLint.
        else if (fileName.startsWith('.')) {
            fileInfo.addUnresolvableImport(fileName);
        }
        // check for path/alias mapping
        else {
            const resolvedTsPath = resolvePotentialTsPath(fileName, paths, resolveFn, fsPath);
            if (resolvedTsPath) {
                importPath = resolvedTsPath;
            }
        }
        if (importPath) {
            const existing = fileInfoDict.get(importPath);
            if (existing) {
                fileInfo.addImport(existing, fileName);
            }
            else if (runOnce) {
                fileInfo.addImport(new unassigned_file_info_1.default(importPath), fileName);
            }
            else {
                fileInfo.addImport(traverseFilesystem(importPath, fileInfoDict, tsData), fileName);
            }
        }
    }
    return fileInfo;
};
function resolvePotentialTsPath(moduleName, tsPaths, resolveFn, filename) {
    let unpathedImport;
    for (const tsPath in tsPaths) {
        const { isWildcard, clearedTsPath } = clearTsPath(tsPath);
        // import from '@app/app.component' & paths: {'@app/*': ['src/app/*']}
        if (isWildcard && moduleName.startsWith(clearedTsPath)) {
            const pathMapping = tsPaths[tsPath];
            unpathedImport = moduleName.replace(clearedTsPath, pathMapping);
        }
        // import from '@app' & paths: { '@app': [''] }
        else if (tsPath === moduleName) {
            unpathedImport = tsPaths[tsPath];
        }
        if (unpathedImport) {
            // path is file -> return as is
            if (isPathFile(unpathedImport)) {
                return fixPathSeparators((0, fs_path_1.toFsPath)(unpathedImport));
            }
            // path is directory or something else -> rely on TypeScript resolvers
            else {
                const resolvedImport = resolveFn(unpathedImport);
                if (!resolvedImport.resolvedModule ||
                    resolvedImport.resolvedModule.isExternalLibraryImport === true) {
                    throw new Error(`unable to resolve import ${moduleName} in ${filename}`);
                }
                return (0, fs_path_1.toFsPath)(fixPathSeparators(resolvedImport.resolvedModule.resolvedFileName));
            }
        }
    }
    return undefined;
}
function clearTsPath(tsPath) {
    const [isWildcard, clearedPath] = tsPath.endsWith('/*')
        ? [true, tsPath.slice(0, -2)]
        : [false, tsPath];
    return { isWildcard, clearedTsPath: clearedPath };
}
/**
 * Ensures that `FsPath` uses the separator from the OS and not always '/'
 *
 * @param path
 */
function fixPathSeparators(path) {
    const fs = (0, getFs_1.default)();
    if (fs.pathSeparator !== '/') {
        return (0, fs_path_1.toFsPath)(path.replace(/\//g, fs.pathSeparator));
    }
    return (0, fs_path_1.toFsPath)(path);
}
/**
 * Checks if the path is a file.
 *
 * For example in tsconfig.json:
 * ```json
 *   "paths": {
 *     "@app": ["src/app/index"]
 *   }
 * ```
 *
 * 'src/app/index' comes already as absolute path with ts extension from
 * pre-processing of @generateTsData.
 *
 * @param path '/.../src/app/index.ts' according to the example above
 */
function isPathFile(path) {
    const fs = (0, getFs_1.default)();
    return fs.exists(path) && (0, fs_path_1.isFsPath)(path) && fs.isFile(path);
}
exports.default = traverseFilesystem;
//# sourceMappingURL=traverse-filesystem.js.map