"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _UnassignedFileInfo_rawImportMap, _UnassignedFileInfo_unresolvableImports;
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFileInfo = void 0;
const fs_path_1 = require("./fs-path");
const throw_if_null_1 = __importDefault(require("../util/throw-if-null"));
const getFs_1 = __importDefault(require("../fs/getFs"));
/**
 * Class representing a TypeScript file with its dependencies.
 * If an import cannot be resolved, it doesn't throw an error
 * but is added to unresolvableImports.
 *
 * It is up to the consumer, e.g. ESLinter, to decide if that
 * should cause an error or not.
 */
class UnassignedFileInfo {
    constructor(path, imports = []) {
        this.path = path;
        this.imports = imports;
        _UnassignedFileInfo_rawImportMap.set(this, new Map());
        _UnassignedFileInfo_unresolvableImports.set(this, []);
    }
    addUnresolvableImport(importCommand) {
        __classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f").push(importCommand);
    }
    isUnresolvableImport(importCommand) {
        return __classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f").includes(importCommand);
    }
    hasUnresolvableImports() {
        return __classPrivateFieldGet(this, _UnassignedFileInfo_unresolvableImports, "f").length > 0;
    }
    addImport(importedFileInfo, rawImport) {
        this.imports.push(importedFileInfo);
        __classPrivateFieldGet(this, _UnassignedFileInfo_rawImportMap, "f").set(importedFileInfo.path, rawImport);
    }
    getRawImportForImportedFileInfo(path) {
        return (0, throw_if_null_1.default)(__classPrivateFieldGet(this, _UnassignedFileInfo_rawImportMap, "f").get(path), `raw import for ${path} is not available in ${this.path}`);
    }
}
_UnassignedFileInfo_rawImportMap = new WeakMap(), _UnassignedFileInfo_unresolvableImports = new WeakMap();
exports.default = UnassignedFileInfo;
const createPath = (path, parentPath) => {
    let currentPath = path;
    if (path.startsWith('./')) {
        const parentPaths = parentPath.split('/');
        parentPaths.pop();
        const normalisedPaths = path.split('/').slice(1);
        currentPath = [...parentPaths, ...normalisedPaths].join('/');
    }
    return currentPath;
};
/**
 * utility function generate a FileInfo Tree for testing purposes
 * @param path
 * @param imports
 */
const buildFileInfo = (path, imports = []) => {
    const fs = (0, getFs_1.default)();
    const children = imports.map((entry) => {
        if (Array.isArray(entry) &&
            entry.length === 2 &&
            typeof entry[0] === 'string') {
            const [childPath, childImports] = entry;
            const currentPath = createPath(childPath, path);
            return (0, exports.buildFileInfo)(currentPath, childImports);
        }
        else if (typeof entry === 'string') {
            return (0, exports.buildFileInfo)(createPath(entry, path), []);
        }
        else {
            throw new Error(`import not in right structure`);
        }
    });
    fs.writeFile(path, '');
    const fileInfo = new UnassignedFileInfo((0, fs_path_1.toFsPath)(path));
    for (const child of children) {
        fileInfo.addImport(child, fs.relativeTo(fileInfo.path, child.path));
    }
    return fileInfo;
};
exports.buildFileInfo = buildFileInfo;
//# sourceMappingURL=unassigned-file-info.js.map